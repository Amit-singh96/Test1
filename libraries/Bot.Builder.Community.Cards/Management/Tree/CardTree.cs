using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Bot.Schema;
using Newtonsoft.Json.Linq;

namespace Bot.Builder.Community.Cards.Nodes
{
    internal static class CardTree
    {
        private const string SpecifyManually = " Try specifying the node type manually instead of using null.";

        private static readonly Dictionary<string, NodeType> _cardTypes = new Dictionary<string, NodeType>(StringComparer.OrdinalIgnoreCase)
        {
            { CardConstants.AdaptiveCardContentType, NodeType.AdaptiveCard },
            { AnimationCard.ContentType, NodeType.AnimationCard },
            { AudioCard.ContentType, NodeType.AudioCard },
            { HeroCard.ContentType, NodeType.HeroCard },
            { ReceiptCard.ContentType, NodeType.ReceiptCard },
            { SigninCard.ContentType, NodeType.SigninCard },
            { OAuthCard.ContentType, NodeType.OAuthCard },
            { ThumbnailCard.ContentType, NodeType.ThumbnailCard },
            { VideoCard.ContentType, NodeType.VideoCard },
        };

        private static readonly Dictionary<NodeType, INode> _tree = new Dictionary<NodeType, INode>
        {
            {
                NodeType.Batch, new ListNode<IMessageActivity>(NodeType.Activity, PayloadIdType.Batch)
            },
            {
                NodeType.Activity, new Node<IMessageActivity, IEnumerable<Attachment>>(async (activity, nextAsync) =>
                {
                    // The nextAsync return value is not needed here because the Attachments property reference will remain unchanged
                    await nextAsync(activity.Attachments, NodeType.Carousel).ConfigureAwait(false);

                    return activity;
                })
            },
            {
                NodeType.Carousel, new ListNode<Attachment>(NodeType.Attachment, PayloadIdType.Carousel)
            },
            {
                NodeType.Attachment, new Node<Attachment, object>(async (attachment, nextAsync) =>
                {
                    if (_cardTypes.ContainsKey(attachment.ContentType))
                    {
                        // The nextAsync return value is needed here because the attachment could be an Adaptive Card
                        // which would mean a new object was generated by the JObject conversion/deconversion
                        attachment.Content = await nextAsync(attachment.Content, _cardTypes[attachment.ContentType]).ConfigureAwait(false);
                    }

                    return attachment;
                })
            },
            {
                NodeType.AdaptiveCard, new Node<object, IEnumerable<JObject>>(async (card, nextAsync) =>
                {
                    // Return the new object after it's been converted to a JObject and back
                    // so that the attachment node can assign it back to the Content property
                    return await card.ToJObjectAndBackAsync(async cardJObject =>
                    {
                        await nextAsync(
                            cardJObject.NonDataDescendants()
                                .Select(token => token is JObject element
                                    && element.GetValue(CardConstants.KeyType, StringComparison.OrdinalIgnoreCase) is JToken type
                                    && type.Type == JTokenType.String
                                    && type.ToString().Equals(
                                        CardConstants.ActionSubmit,
                                        StringComparison.OrdinalIgnoreCase)
                                    ? element : null)
                                .WhereNotNull(), NodeType.SubmitActionList).ConfigureAwait(false);
                    }).ConfigureAwait(false);
                })
            },
            {
                NodeType.AnimationCard, new RichCardNode<AnimationCard>(card => card.Buttons)
            },
            {
                NodeType.AudioCard, new RichCardNode<AudioCard>(card => card.Buttons)
            },
            {
                NodeType.HeroCard, new RichCardNode<HeroCard>(card => card.Buttons)
            },
            {
                NodeType.OAuthCard, new RichCardNode<OAuthCard>(card => card.Buttons)
            },
            {
                NodeType.ReceiptCard, new RichCardNode<ReceiptCard>(card => card.Buttons)
            },
            {
                NodeType.SigninCard, new RichCardNode<SigninCard>(card => card.Buttons)
            },
            {
                NodeType.ThumbnailCard, new RichCardNode<ThumbnailCard>(card => card.Buttons)
            },
            {
                NodeType.VideoCard, new RichCardNode<VideoCard>(card => card.Buttons)
            },
            {
                NodeType.SubmitActionList, new ListNode<object>(NodeType.SubmitAction, PayloadIdType.Card)
            },
            {
                NodeType.CardActionList, new ListNode<CardAction>(NodeType.CardAction, PayloadIdType.Card)
            },
            {
                NodeType.SubmitAction, new Node<object, JObject>(async (action, nextAsync) =>
                {
                    // If the entry point was the Adaptive Card or higher
                    // then the action will already be a JObject
                    return await action.ToJObjectAndBackAsync(
                        async actionJObject =>
                        {
                            var data = actionJObject.GetValue(CardConstants.KeyData, StringComparison.OrdinalIgnoreCase);

                            if (data is JObject dataJObject)
                            {
                                await nextAsync(dataJObject, NodeType.Payload).ConfigureAwait(false); 
                            }
                        }, true).ConfigureAwait(false);
                })
            },
            {
                NodeType.CardAction, new Node<CardAction, JObject>(async (action, nextAsync) =>
                {
                    if (action.Type == ActionTypes.MessageBack || action.Type == ActionTypes.PostBack)
                    {
                        async Task CallNextAsync(JObject jObject)
                        {
                            await nextAsync(jObject, NodeType.Payload).ConfigureAwait(false);
                        }

                        var valueResult = await action.Value.ToJObjectAndBackAsync(
                            CallNextAsync,
                            true,
                            true).CoalesceAwait();

                        if (valueResult != null)
                        {
                            action.Value = valueResult;
                        }
                        else
                        {
                            var textResult = await action.Text.ToJObjectAndBackAsync(
                                CallNextAsync,
                                true,
                                true).CoalesceAwait();

                            if (textResult != null)
                            {
                                action.Text = textResult;
                            }
                        }
                    }

                    return action;
                })
            },
            {
                NodeType.Payload, new Node<object, PayloadId>(async (payload, nextAsync) =>
                {
                    return await payload.ToJObjectAndBackAsync(async payloadJObject =>
                    {
                        foreach (var type in Helper.GetEnumValues<PayloadIdType>())
                        {
                            var id = payloadJObject.GetIdFromPayload(type);

                            if (id != null)
                            {
                                await nextAsync(new PayloadId(type, id), NodeType.Id);
                            }
                        }
                    });
                })
            },
            {
                NodeType.Id, new Node<PayloadId, object>((id, _) => Task.FromResult(id))
            },
        };

        internal static async Task<TEntry> RecurseAsync<TEntry, TExit>(
            TEntry entryValue,
            Func<TExit, Task> funcAsync,
            NodeType? entryType = null,
            NodeType? exitType = null)
            where TEntry : class
            where TExit : class
        {
            INode entryNode = null;
            INode exitNode = null;

            try
            {
                entryNode = GetNode<TEntry>(entryType);
            }
            catch (Exception ex)
            {
                throw GetNodeArgumentException<TEntry>(ex);
            }

            try
            {
                exitNode = GetNode<TExit>(exitType);
            }
            catch (Exception ex)
            {
                throw GetNodeArgumentException<TExit>(ex, "exit");
            }

            async Task<object> NextAsync(object child, NodeType childType)
            {
                var childNode = _tree[childType];

                if (childNode == exitNode)
                {
                    await funcAsync(child is JToken jToken ? jToken.ToObject<TExit>() : child as TExit).ConfigureAwait(false);

                    return child;
                }
                else
                {
                    return await childNode.CallChild(child, NextAsync).ConfigureAwait(false);
                }
            }

            return await entryNode.CallChild(entryValue, NextAsync).ConfigureAwait(false) as TEntry;
        }

        internal static TEntry ApplyIds<TEntry>(TEntry entryValue, PayloadIdOptions options = null, NodeType? entryType = null)
            where TEntry : class
        {
            INode entryNode = null;

            try
            {
                entryNode = GetNode<TEntry>(entryType);
            }
            catch (Exception ex)
            {
                throw GetNodeArgumentException<TEntry>(ex);
            }

            Task<object> NextAsync(object child, NodeType childType)
            {
                if (childType == NodeType.Payload)
                {
                    return child.ToJObjectAndBackAsync(
                        payload =>
                        {
                            payload.ApplyIdsToPayload(options);

                            return Task.CompletedTask;
                        }, true);
                }
                else
                {
                    var childNode = _tree[childType];

                    if (childNode.IdType.HasValue)
                    {
                        var idType = childNode.IdType.Value;

                        idType.ReplaceNullWithId(ref options);

                        foreach (var item in options.GetIdTypes().Where(it => it > idType))
                        {
                            options.Set(idType);
                        }
                    }

                    return childNode.CallChild(child, NextAsync);
                }
            }

            return entryNode.CallChild(entryValue, NextAsync).Result as TEntry;
        }

        private static INode GetNode<T>(NodeType? nodeType)
        {
            var t = typeof(T);

            if (nodeType is null)
            {
                if (t == typeof(object))
                {
                    throw new Exception("A node cannot be automatically determined from a System.Object type argument." + SpecifyManually);
                }

                var matchingNodes = new List<INode>();

                foreach (var possibleNode in _tree.Values)
                {
                    if (possibleNode.GetTValue().IsAssignableFrom(t))
                    {
                        matchingNodes.Add(possibleNode);
                    }
                }

                var count = matchingNodes.Count();

                if (count < 1)
                {
                    throw new Exception($"No node exists that's assignable from the type argument: {t}. Try using a different type.");
                }

                if (count > 1)
                {
                    throw new Exception($"Multiple nodes exist that are assignable from the type argument: {t}." + SpecifyManually);
                }

                return matchingNodes.First();
            }

            var exactNode = _tree[nodeType.Value];

            return exactNode.GetTValue().IsAssignableFrom(t)
                ? exactNode
                : throw new Exception($"The node type {nodeType} is not assignable from the type argument: {t}."
                    + " Make sure you're providing the correct node type.");
        }

        private static ArgumentException GetNodeArgumentException<TEntry>(Exception inner, string entryOrExit = "entry")
        {
            return new ArgumentException(
                $"The {entryOrExit} node could not be determined from the type argument: {typeof(TEntry)}.",
                $"{entryOrExit}Type",
                inner);
        }
    }
}
